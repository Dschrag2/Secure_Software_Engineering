import com.ibm.wala.cast.tree.impl.CAstNodeTypeMapRecorder;
import com.ibm.wala.classLoader.IClass;
import com.ibm.wala.classLoader.IMethod;
import com.ibm.wala.ipa.callgraph.*;
import com.ibm.wala.ipa.callgraph.impl.Util;
import com.ibm.wala.ipa.callgraph.propagation.InstanceKey;
import com.ibm.wala.ipa.callgraph.propagation.SSAPropagationCallGraphBuilder;
import com.ibm.wala.ipa.cha.ClassHierarchyException;
import com.ibm.wala.ipa.cha.ClassHierarchyFactory;
import com.ibm.wala.ipa.cha.IClassHierarchy;
import com.ibm.wala.ipa.slicer.*;
import com.ibm.wala.ssa.*;
import com.ibm.wala.types.*;
import com.ibm.wala.util.CancelException;
import com.ibm.wala.util.collections.HashSetFactory;
import com.ibm.wala.util.config.FileOfClasses;
import com.ibm.wala.util.graph.Graph;
import com.ibm.wala.util.graph.GraphSlicer;
import com.ibm.wala.util.graph.traverse.BFSPathFinder;
import com.ibm.wala.util.strings.Atom;

import java.io.FileInputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.sql.SQLOutput;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.jar.JarFile;

import static com.ibm.wala.types.TypeReference.findOrCreate;

public class VulnerabilityFinder {

    public static void printCallGraph(CallGraph cg, String callgraphName) {
        System.out.println("================ " + callgraphName + " call graph ===================");
        System.out.println(CallGraphStats.getStats(cg));
        System.out.println("Call Graph (application scope only): ");
        for (CGNode n : cg) {

            if (n.getMethod().getDeclaringClass().getClassLoader().getReference().equals(ClassLoaderReference.Application)) {
                cg.getSuccNodes(n).forEachRemaining(next -> {
                    System.out.print("\"" + n.getMethod().getSignature() + "\"");
                    System.out.println(" -> \"" + next.getMethod().getSignature() + "\"");
                });
                System.out.println("");
            }
        }
        System.out.println("===================================================");
    }

    public static void main(String[] args) throws Exception {
        // Implement your solution here
        System.out.println("----- Part 1 -----");

        // Create the analysis scope
        AnalysisScope scope = AnalysisScope.createJavaAnalysisScope();
        String jarFilePath = VulnerabilityFinder.class.getResource("Sample.jar").getPath();
        scope.addToScope(ClassLoaderReference.Application, new JarFile(jarFilePath));
        String jrePath = VulnerabilityFinder.class.getResource("jdk-17.0.1/rt.jar").getPath();
        scope.addToScope(ClassLoaderReference.Primordial, new JarFile(jrePath));
        String exFilePath = VulnerabilityFinder.class.getResource("Java60RegressionExclusions.txt").getPath();
        scope.setExclusions(new FileOfClasses(new FileInputStream(exFilePath)));

        // Create the class hierarchy
        IClassHierarchy classHierarchy = ClassHierarchyFactory.make(scope);

        // Print the number of classes in the class hierarchy
        System.out.println("Number of classes: " + classHierarchy.getNumberOfClasses());
        int primordialCount = 0;
        int applicationCount = 0;

        for (IClass iClass : classHierarchy) {
            ClassLoaderReference clr = iClass.getClassLoader().getReference();

            if (clr.equals(ClassLoaderReference.Primordial)) {
                primordialCount++;
            } else if (clr.equals(ClassLoaderReference.Application)) {
                applicationCount++;
            } 
        }

        // Print the number of classes in each scope
        System.out.println("Number of primordial classes: " + primordialCount);
        System.out.println("Number of application classes: " + applicationCount);

        // ------ Part 2 -----
        System.out.println("----- Part 2 -----");
        // Create the 1-CFA call graph
        AnalysisOptions options = new AnalysisOptions();
        Iterable<Entrypoint> entrypoints = Util.makeMainEntrypoints(scope, classHierarchy);
        options.setEntrypoints(entrypoints);
        SSAPropagationCallGraphBuilder builder = Util.makeNCFABuilder(1, options, new AnalysisCacheImpl(), classHierarchy, scope);
        CallGraph callGraph = builder.makeCallGraph(options, null);
        // printCallGraph(callGraph, "1-CFA");

        // Print the number of nodes and edges
        System.out.println("Number of nodes: " + callGraph.getNumberOfNodes());

        int edgeCount = 0;
        for (CGNode node : callGraph) {
            edgeCount += callGraph.getSuccNodeCount(node);
        }
        System.out.println("Number of edges: " + edgeCount);

        // ----- Part 3 -----
        System.out.println("----- Part 3 -----");
        // Compute the SDG of the program (data only)
        SDG<InstanceKey> sdg = new SDG<>(callGraph,
                builder.getPointerAnalysis(),
                Slicer.DataDependenceOptions.NO_BASE_NO_HEAP_NO_EXCEPTIONS,
                Slicer.ControlDependenceOptions.NO_EXCEPTIONAL_EDGES);

        // Find sources and sinks
        Set<Statement> sources = findSources(sdg);
        Set<Statement> sinks = findSinks(sdg);
        System.out.println("SOURCES: " + sources);
        System.out.println("SINKS: " + sinks);


        // Slice the SDG and compute a pruned SDG
        // Set<Statement> slice = new HashSet<>(Slicer.computeBackwardSlice(sdg, sinks));
        // Graph<Statement> slicedSdg = GraphSlicer.prune(sdg, s -> slice.contains(s));

        // Find vulnerable paths
        Set<List<Statement>> paths = getVulnerablePaths(sdg, sources, sinks);

        // Print Vulnerable Paths
        for(List<Statement> path : paths) {
            System.out.println("PATH: " );
            for(Statement s : path) {
                System.out.println("\t"+s);
            }
        }

        // Write vulnerable paths to file
        String outputFilename = "tainted_flows.txt";
        try (PrintWriter writer = new PrintWriter(new FileWriter(outputFilename))) {
            if (paths.isEmpty()) {
                System.out.println("No vulnerable paths found.");
                writer.println("No vulnerable paths found.");
            } else {
                System.out.println("Found " + paths.size() + " vulnerable path(s). Writing to " + outputFilename);
                int pathCount = 1;
                for (List<Statement> path : paths) {
                    writer.println("--- VULNERABLE FLOW " + (pathCount++) + " ---");
                    System.out.println("\n--- VULNERABLE FLOW " + pathCount + " ---");
                    for (Statement s : path) {
                        // 's.toString()' gives good detail on the statement
                        String statementDetails = s.toString();
                        writer.println("\t" + statementDetails);
                        System.out.println("\t" + statementDetails);
                    }
                    writer.println("--- END OF FLOW ---");
                    System.out.println("--- END OF FLOW ---");
                }
            }
        } catch (IOException e) {
            System.err.println("Error writing vulnerabilities to file: " + e.getMessage());
            e.printStackTrace();
        }

        System.out.println("Analysis complete. Results are in " + outputFilename);
    }

    /**
     * True if the IClass is under the application-scope ({@code ClassLoaderReference.Application}).
     *
     * @param iClass
     * @return
     */
    public static boolean isApplicationScope(IClass iClass) {
        return iClass != null && iClass.getClassLoader().getReference().equals(ClassLoaderReference.Application);
    }

    /**
     * Find all the sources in the SDG.
     *
     * @param sdg SDG
     * @return Set of sources
     */
    public static Set<Statement> findSources(SDG<InstanceKey> sdg) {

        Set<Statement> result = new HashSet<>();

        // Define the MethodReference for java.io.BufferedReader.readLine()
        TypeReference bufferedReaderType =
                findOrCreate(ClassLoaderReference.Application, TypeName.string2TypeName("Ljava/io/BufferedReader"));
        MethodReference readLineRef =
                MethodReference.findOrCreate(bufferedReaderType,
                        Atom.findOrCreateUnicodeAtom("readLine"),
                        Descriptor.findOrCreateUTF8("()Ljava/lang/String;"));

        for (Statement s : sdg) {
            if (s.getKind().equals(Statement.Kind.NORMAL) && isApplicationScope(s.getNode().getMethod().getDeclaringClass())) {
                SSAInstruction instruction = ((NormalStatement) s).getInstruction();
                if (instruction instanceof SSAArrayLoadInstruction) {
                    int varNo = instruction.getUse(0);
                    String method = s.getNode().getMethod().getSelector().toString();
                    if (varNo == 1 && method.equals("main([Ljava/lang/String;)V"))
                        result.add(s);
                }
            }
        }

        // Iterate over the statements in the SDG to find read line sources
        for (Statement statement : sdg) {
            if (isApplicationScope(statement.getNode().getMethod().getDeclaringClass())) {
                if (statement instanceof NormalStatement) {
                    SSAInstruction instruction = ((NormalStatement) statement).getInstruction();
                    // We are looking for the *call* to readLine()
                    if (instruction instanceof SSAInvokeInstruction) {
                        SSAInvokeInstruction invoke = (SSAInvokeInstruction) instruction;
                        if (invoke.getDeclaredTarget().equals(readLineRef)) {
                            // This statement is the call to readLine().
                            // The data flows *from* this statement (as its return value).
                            result.add(statement);
                        }
                    }
                }
            }
        }
        return result;
    }

    /**
     * Find all the sinks in the SDG.
     *
     * @param sdg SDG
     * @return Set of sinks
     */
    public static Set<Statement> findSinks(SDG<InstanceKey> sdg) {
        TypeReference JavaLangRuntime =
                findOrCreate(ClassLoaderReference.Application, TypeName.string2TypeName("Ljava/lang/Runtime"));
        MethodReference sinkReference =
                MethodReference.findOrCreate(JavaLangRuntime,
                        Atom.findOrCreateUnicodeAtom("exec"),
                        Descriptor.findOrCreateUTF8("(Ljava/lang/String;)Ljava/lang/Process;"));

        Set<Statement> result = new HashSet<>();
        for (Statement s : sdg) {
            if (s.getKind().equals(Statement.Kind.NORMAL) && isApplicationScope(s.getNode().getMethod().getDeclaringClass())) {
                SSAInstruction instruction = ((NormalStatement) s).getInstruction();
                if (instruction instanceof SSAAbstractInvokeInstruction) {
                    if (((SSAAbstractInvokeInstruction) instruction).getDeclaredTarget().equals(sinkReference))
                        result.add(s);
                }
            }
        }
        return result;
    }

    public static Set<List<Statement>> getVulnerablePaths(Graph<Statement> G, Set<Statement> sources, Set<Statement> sinks) {
        Set<List<Statement>> result = HashSetFactory.make();
        for (Statement src : sources) {
            for (Statement dst: sinks ) {
                BFSPathFinder<Statement> paths = new BFSPathFinder<>(G, src, dst);
                List<Statement> path = paths.find();
                if (path != null) {
                    result.add(path);
                }
            }
        }

        return result;
    }
}
